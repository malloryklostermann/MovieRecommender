---
title: Project 4
author: 'Ibtisaam Dalvi, Mallory Klostermann; netIDs: idalvi2, mallory6'
output: html_document
editor_options: 
  chunk_output_type: console
---

### Importing packages & data
```{r, message = FALSE}
library(tidyverse)
library(rsconnect)
movies = read_csv("movies.csv")[-1]
ratings = as.data.frame(read_csv("ratings.csv")[-1])
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
```

# System I: Recommendation Based on Genres
We decided to recommend based on the highest mean rating of the movies in that genre with more than 200 reviews.
```{r}
gen_rec = function(genre) {
  movies = read_csv("movies.csv")[-1]
  
  ratings = as.data.frame(read_csv("ratings.csv")[-1])
  colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
  
  full = left_join(ratings, movies, by = "MovieID")
  
  full %>% 
      group_by(MovieID) %>% 
      filter(grepl(genre, Genres)) %>% 
      summarise(avg_rating = mean(Rating), n = n()) %>% 
      filter(n > 200) %>% 
      arrange(desc(avg_rating)) %>% 
      head(10)
  
}
```


# System II: Recommendation Based on IBCF
### Generating centered ratings matrix
```{r, message = FALSE}
R = sapply(sort(unique(ratings$MovieID)), function(movie) {
  left_join(data.frame(UserID = sort(unique(ratings$UserID))), 
            ratings[which(ratings$MovieID == movie), ][, c(1, 3)], by = "UserID")[, 2]
})

colnames(R) = paste0("m", sort(unique(ratings$MovieID)))
rownames(R) = paste0("u", sort(unique(ratings$UserID)))
  
# centering rows of ratings matrix
D = t(apply(R, 1, function(row) { scale(row, scale = FALSE) }))
```

### Getting cosine similarity
```{r, eval = FALSE, warning = FALSE}
preS = matrix(NA, 3706, 3706)

count = 1
for (i in 1:3706) {
  for (j in 1:3706) {
    
    # get users who have rated both movies i and j
    users = !is.na(D[, i]) & !is.na(D[, j])
    
    # if 3 users have rated both movies i and j, contribute to overall sums
    if (sum(users) >= 3) {
      preS[i, j] = 0.5 + (0.5 * sum(D[users, i] * D[users, j]) / sqrt(sum(D[users, i]^2) * sum(D[users, j]^2)))
    }
    print(paste0(count, "/", 3706^2))
    count = count + 1
  }
}

diag(preS) = NA
#write.csv(preS, "similarity.csv")
```

### Testing specified movies before getting top 30
```{r, message = FALSE, warning = FALSE}
preS = as.matrix(read_csv("similarity.csv")[, -1])
colnames(preS) = paste0("m", sort(unique(ratings$MovieID)))
rownames(preS) = paste0("m", sort(unique(ratings$MovieID)))
test = c("m1", "m10", "m100", "m1510", "m260", "m3212")
preS[test, test]
```

### Changing S to contain top 30
```{r, eval = FALSE}
S = t(apply(preS, 1, function(row) {
  top30 = names(row[order(row, decreasing = TRUE)][1:30])
  ifelse(names(row) %in% top30, row, NA)
}))
#write.csv(S, "sim.csv")
```

### Testing specified movies after getting top 30
```{r, message = FALSE, warning = FALSE}
S = as.matrix(read_csv("sim.csv"))
colnames(S) = paste0("m", sort(unique(ratings$MovieID)))
rownames(S) = paste0("m", sort(unique(ratings$MovieID)))
S[test, test]
```

### myIBCF function
When fewer than 10 predictions are non-NA, we find the most common genre among the movies that were recommended and use System I to recommend the remaining movies. If there was a tie for most common genre, we select one of the top genres at random and do the same thing. If there were no non-NA predictions, we select movies at random from all genres.
```{r, warning = FALSE}
myIBCF = function(newuser) {
  
  movies = read_csv("movies.csv")[-1]
  
  ratings = as.data.frame(read_csv("ratings.csv")[-1])
  colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
  
  S = as.matrix(read_csv("sim.csv"))
  colnames(S) = paste0("m", sort(unique(ratings$MovieID)))
  rownames(S) = paste0("m", sort(unique(ratings$MovieID)))
  
  preds = c()
  for (l in rownames(S)) {
    s = S[l, which(!is.na(S[l, ]))]
    w = newuser[which(!is.na(S[l, ]))]
    
    pred = sum(s * w, na.rm = TRUE) / sum(s * ifelse(!is.na(w), 1, 0), na.rm = TRUE)
    preds = c(preds, pred)
  }
  
  # setting already rated movies to NA
  preds[!is.na(newuser)] = NA
  
  # getting top 10 predicted ratings
  names(preds) = colnames(S)
  toReturn = data.frame(movie = names(preds[order(preds, decreasing = TRUE)][1:10]), 
                        predicted = preds[order(preds, decreasing = TRUE)][1:10])
  
  # in case there are less than 10 non-NA predictions
  if (!all(!is.na(toReturn$predicted))) {
    
    # getting NA indices
    NAs = which(is.na(toReturn$predicted))
    nonNAs = which(!is.na(toReturn$predicted))
    
    # if all are NA, randomly return movies
    if (length(nonNAs) == 0) {
      toReturn$movie = sample(colnames(S), 10)
      
      # otherwise get top genre of those recommended and use part 1 recommender
    } else {
      
      # getting IDs of movies that have already been recommended
      IDs = data.frame(MovieID = as.numeric(str_remove_all(toReturn$movie[nonNAs], "m")))
      
      # getting genre counts of movies that have already been recommended
      tab = table(unname(unlist(sapply(left_join(IDs, movies, by = "MovieID")$Genres, function(movie) {
        strsplit(movie, "|", fixed = TRUE)
      }))))
      
      # getting top genre(s) of movies that have already been recommended
      topgenres = which(tab == max(tab))
      
      # if tie for top genre, select one and output movies using part 1
      if (length(topgenres) > 1) {
        toReturn$movie[NAs] = paste0("m", gen_rec(names(tab)[sample(topgenres, 1)])$MovieID[1:length(NAs)])
      } else {
        toReturn$movie[NAs] = paste0("m", gen_rec(names(tab)[which.max(tab)])$MovieID[1:length(NAs)])
      }
      
    }
    
  }
  
  toReturn
  
}

```

### testing specified users
```{r, warning = FALSE, message = FALSE}
myIBCF(R["u1181", ])
myIBCF(R["u1351", ])

# “m1613” with 5 and “m1755” with 4.
rando = rep(NA, 3706)
rando[c(which(colnames(S) == "m1613"), which(colnames(S) == "m1755"))] = c(5, 4)
names(rando) = rownames(S)

myIBCF(rando)
```
